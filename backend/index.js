// index.js
require('dotenv').config();
const { Telegraf } = require('telegraf');

const BOT_TOKEN = process.env.BOT_TOKEN;
const CHANNEL_ID = process.env.CHANNEL_ID; // like -1001234567890
if (!BOT_TOKEN || !CHANNEL_ID) {
  console.error("Please set BOT_TOKEN and CHANNEL_ID in .env");
  process.exit(1);
}

const bot = new Telegraf(BOT_TOKEN);

// In-memory stores (replace with DB for production)
const inviteDurations = new Map(); // invite_link -> milliseconds
const expiringUsers = new Map();   // userId -> expiryTimestamp (ms)

const logger = console;

// Utility: parse "1h" / "30m" / "2d"
function parseDuration(spec) {
  if (!spec) throw new Error('Empty duration');
  const m = spec.match(/^(\d+)([mhd])$/i);
  if (!m) throw new Error("Invalid format. Use 30m / 1h / 2d");
  const value = parseInt(m[1], 10);
  const unit = m[2].toLowerCase();
  if (unit === 'm') return value * 60 * 1000;
  if (unit === 'h') return value * 60 * 60 * 1000;
  if (unit === 'd') return value * 24 * 60 * 60 * 1000;
  throw new Error('Invalid unit');
}

// Check if user is admin in the channel
async function isAdmin(userId) {
  try {
    const member = await bot.telegram.getChatMember(CHANNEL_ID, userId);
    return ['administrator', 'creator'].includes(member.status);
  } catch (err) {
    logger.error('isAdmin error', err);
    return false;
  }
}

// /getlink command
bot.command('getlink', async (ctx) => {
  try {
    const fromId = ctx.from.id;
    if (!(await isAdmin(fromId))) {
      return ctx.reply('❌ Tamne permission nathi — admin j /getlink chalaavi sake.');
    }

    const parts = ctx.message.text.trim().split(/\s+/);
    if (parts.length < 2) {
      return ctx.reply('❌ Usage: /getlink <value><unit>\nExamples: /getlink 1h  or  /getlink 30m');
    }
    const spec = parts[1];
    let ms;
    try {
      ms = parseDuration(spec);
    } catch (e) {
      return ctx.reply('❌ Invalid format. Use e.g. 30m / 1h / 2d');
    }

    // create_chat_invite_link with creates_join_request true
    const res = await bot.telegram.createChatInviteLink(CHANNEL_ID, {
      creates_join_request: true,
      // member_limit cannot be combined with creates_join_request; skip it.
      // expires_date: optionally set expires_date (server-side), but we track expiration ourselves.
    });

    const inviteLink = res.invite_link;
    inviteDurations.set(inviteLink, ms);

    await ctx.replyWithMarkdown(
      `✅ Approval link valid for *${spec}*:\n\n\`${inviteLink}\`\n\n` +
      'When a user clicks this, I will approve them and start their timer.'
    );

    logger.info(`Generated approval link ${inviteLink} for duration ${ms}ms`);
  } catch (err) {
    logger.error('getlink error', err);
    ctx.reply('❌ Error while creating link. Check bot permissions (must be admin with invite link rights).');
  }
});

// Handle incoming chat join requests (update type: chat_join_request)
bot.on('chat_join_request', async (ctx) => {
  try {
    const req = ctx.update.chat_join_request;
    const user = req.from;
    const invite_link = req.invite_link?.invite_link || null;

    logger.info('Received join request', { userId: user.id, invite_link });

    // Auto-approve only if invite_link exists and was generated by us
    if (!invite_link || !inviteDurations.has(invite_link)) {
      // Optionally: decline or ignore
      logger.info('No known invite link; ignoring request');
      return;
    }

    // Approve the join request
    await bot.telegram.approveChatJoinRequest(CHANNEL_ID, user.id);
    logger.info(`Approved join request for ${user.id}`);

    // Start expiry timer for this user
    const durationMs = inviteDurations.get(invite_link);
    const expiresAt = Date.now() + durationMs;
    expiringUsers.set(user.id, expiresAt);

    // Optionally send DM or notify admin
    try {
      await bot.telegram.sendMessage(user.id, `You were approved to join the channel. Your temporary access will expire in ${Math.round(durationMs/60000)} minutes.`);
    } catch (e) {
      // user may have privacy settings — ignore
      logger.info('Could not message user (likely privacy settings)');
    }
  } catch (err) {
    logger.error('chat_join_request handler error', err);
  }
});

// Background job: run every 30 seconds to remove expired users
setInterval(async () => {
  try {
    const now = Date.now();
    const toKick = [];
    for (const [userId, expiresAt] of expiringUsers.entries()) {
      if (expiresAt <= now) toKick.push(userId);
    }
    if (toKick.length === 0) return;

    let usersKicked = 0;
    for (const userId of toKick) {
      try {
        logger.info(`KICK_JOB: Processing user ${userId}`);
        // Ban
        await bot.telegram.banChatMember(CHANNEL_ID, userId);
        logger.info(`KICK_JOB: Ban successful for ${userId}`);
        // Unban immediately so user can be re-invited later
        await bot.telegram.unbanChatMember(CHANNEL_ID, userId);
        logger.info(`KICK_JOB: Unban successful for ${userId}`);
        usersKicked += 1;
      } catch (e) {
        logger.error(`KICK_JOB: EXCEPTION for user ${userId}`, e);
      } finally {
        expiringUsers.delete(userId);
      }
    }
    if (usersKicked > 0) logger.info(`KICK_JOB: Completed. Users kicked: ${usersKicked}`);
  } catch (err) {
    logger.error('KICK_JOB: outer error', err);
  }
}, 30 * 1000);

console.log("Step 1: File started loading");

(async () => {
  try {
    console.log("Step 2: Before bot.launch()");
    await bot.launch();
    console.log("Step 3: After bot.launch()");
    logger.info('Bot started (polling).');

    process.once('SIGINT', () => bot.stop('SIGINT'));
    process.once('SIGTERM', () => bot.stop('SIGTERM'));
  } catch (err) {
    console.error("Step ERR: ", err);
    logger.error('Failed to start bot', err);
  }
})();

console.log("Step 4: End of file reached");
